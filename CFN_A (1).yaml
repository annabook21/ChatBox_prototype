AWSTemplateFormatVersion: '2010-09-09'
Description: >-
  Production-ready Contextual Chatbot with Amazon Bedrock AgentCore Runtime.

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label: { default: "Project Configuration" }
        Parameters: [ProjectName, Environment, DomainName]
      - Label: { default: "Bedrock Configuration" }
        Parameters: [BedrockRegion, EmbeddingModelId, FoundationModelId]
      - Label: { default: "Network Configuration" }
        Parameters: [VpcCidr, PrivateSubnetACidr, PrivateSubnetBCidr, PublicSubnetACidr, PublicSubnetBCidr]
      - Label: { default: "AgentCore Configuration" }
        Parameters: [EnableHybridSearch, EnableAgentCoreMemory, AgentCodeS3Bucket, AgentCodeS3Key]
      - Label: { default: "Cost Control" }
        Parameters: [EnableCostAlerts, MonthlyBudgetAmount]

Parameters:
  ProjectName:
    Type: String
    Default: contextual-chatbot
    AllowedPattern: '^[a-z][a-z0-9\-]*$'
    MaxLength: 30
    Description: "Project name (lowercase, hyphens allowed)"
  
  Environment:
    Type: String
    Default: dev
    AllowedValues: [dev, staging, prod]
    Description: "Deployment environment"
  
  DomainName:
    Type: String
    Default: "<YourDomainName>"
    Description: "Custom domain for frontend (optional)"
  
  BedrockRegion:
    Type: String
    Default: us-east-1
    AllowedValues: [us-east-1, us-west-2, eu-west-1, ap-southeast-1]
    Description: "AWS Region for Bedrock services"
  
  EmbeddingModelId:
    Type: String
    Default: amazon.titan-embed-text-v1
    AllowedValues: [amazon.titan-embed-text-v1, cohere.embed-english-v3, cohere.embed-multilingual-v3]
    Description: "Bedrock embedding model for vectorization"
  
  FoundationModelId:
    Type: String
    Default: anthropic.claude-3-5-sonnet-20241022-v2:0
    Description: "Foundation model for text generation. Latest: Claude Sonnet 4.5, Claude 3.5 Sonnet v2, Claude 3.7 Sonnet"
    AllowedValues:
      # Latest Claude 4.x models
      - anthropic.claude-sonnet-4-5-20250929-v1:0
      - anthropic.claude-sonnet-4-20250514-v1:0
      - anthropic.claude-opus-4-1-20250805-v1:0
      - anthropic.claude-opus-4-20250514-v1:0
      # Claude 3.7
      - anthropic.claude-3-7-sonnet-20250219-v1:0
      # Claude 3.5 models (recommended for most use cases)
      - anthropic.claude-3-5-sonnet-20241022-v2:0
      - anthropic.claude-3-5-sonnet-20240620-v1:0
      - anthropic.claude-3-5-haiku-20241022-v1:0
      # Claude 3.x models
      - anthropic.claude-3-opus-20240229-v1:0
      - anthropic.claude-3-sonnet-20240229-v1:0
      - anthropic.claude-3-haiku-20240307-v1:0
  
  VpcCidr:
    Type: String
    Default: 10.0.0.0/16
  
  PrivateSubnetACidr:
    Type: String
    Default: 10.0.1.0/24
  
  PrivateSubnetBCidr:
    Type: String
    Default: 10.0.2.0/24
  
  PublicSubnetACidr:
    Type: String
    Default: 10.0.101.0/24
  
  PublicSubnetBCidr:
    Type: String
    Default: 10.0.102.0/24
  
  EnableHybridSearch:
    Type: String
    Default: "true"
    AllowedValues: ["true", "false"]
    Description: "Enable hybrid search (semantic + keyword)"
  
  EnableAgentCoreMemory:
    Type: String
    Default: "true"
    AllowedValues: ["true", "false"]
    Description: "Enable AgentCore Memory for conversation context"
  
  AgentCodeS3Bucket:
    Type: String
    Default: ""
    Description: "S3 bucket containing agent code (leave empty to use inline code)"
  
  AgentCodeS3Key:
    Type: String
    Default: "agent/agent.py"
    Description: "S3 key for agent code file"
  
  EnableCostAlerts:
    Type: String
    Default: "true"
    AllowedValues: ["true", "false"]
  
  MonthlyBudgetAmount:
    Type: Number
    Default: 100
    MinValue: 10
    MaxValue: 10000

Conditions:
  IsProd: !Equals [!Ref Environment, prod]
  EnableCostAlertsCondition: !Equals [!Ref EnableCostAlerts, "true"]
  HasCustomDomain: !Not [!Equals [!Ref DomainName, "<YourDomainName>"]]
  UseAgentCoreMemory: !Equals [!Ref EnableAgentCoreMemory, "true"]
  HasAgentCodeInS3: !Not [!Equals [!Ref AgentCodeS3Bucket, ""]]

Resources:

  ########################################
  # KMS Encryption
  # Reference: https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html
  ########################################
  MasterKMSKey:
    Type: AWS::KMS::Key
    Properties:
      Description: !Sub "CMK for ${ProjectName}-${Environment}"
      EnableKeyRotation: true
      KeyPolicy:
        Version: '2012-10-17'
        Statement:
          - Sid: AllowRootAccount
            Effect: Allow
            Principal:
              AWS: !Sub "arn:aws:iam::${AWS::AccountId}:root"
            Action: "kms:*"
            Resource: "*"
          - Sid: AllowS3Service
            Effect: Allow
            Principal:
              Service: s3.amazonaws.com
            Action:
              - kms:Decrypt
              - kms:Encrypt
              - kms:ReEncrypt*
              - kms:GenerateDataKey*
              - kms:DescribeKey
            Resource: "*"
            Condition:
              StringEquals:
                kms:ViaService: !Sub "s3.${AWS::Region}.amazonaws.com"
          - Sid: AllowCloudWatchLogs
            Effect: Allow
            Principal:
              Service: !Sub "logs.${AWS::Region}.amazonaws.com"
            Action:
              - kms:Encrypt
              - kms:Decrypt
              - kms:ReEncrypt*
              - kms:GenerateDataKey*
              - kms:CreateGrant
              - kms:DescribeKey
            Resource: "*"
            Condition:
              ArnLike:
                kms:EncryptionContext:aws:logs:arn: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*"
          - Sid: AllowBedrockService
            Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action:
              - kms:Decrypt
              - kms:GenerateDataKey*
            Resource: "*"
          - Sid: AllowSNSService
            Effect: Allow
            Principal:
              Service: sns.amazonaws.com
            Action:
              - kms:Decrypt
              - kms:GenerateDataKey*
            Resource: "*"

  MasterKMSKeyAlias:
    Type: AWS::KMS::Alias
    Properties:
      AliasName: !Sub "alias/${ProjectName}-${Environment}"
      TargetKeyId: !Ref MasterKMSKey

  ########################################
  # ECR Repository for AgentCore Container
  # Reference: https://docs.aws.amazon.com/AmazonECR/latest/userguide/what-is-ecr.html
  ########################################
  AgentCoreECRRepository:
    Type: AWS::ECR::Repository
    Properties:
      RepositoryName: !Sub "${ProjectName}-${Environment}-agent"
      ImageScanningConfiguration:
        ScanOnPush: true
      EncryptionConfiguration:
        EncryptionType: KMS
        KmsKey: !Ref MasterKMSKey
      LifecyclePolicy:
        LifecyclePolicyText: |
          {
            "rules": [
              {
                "rulePriority": 1,
                "description": "Keep last 5 images",
                "selection": {
                  "tagStatus": "any",
                  "countType": "imageCountMoreThan",
                  "countNumber": 5
                },
                "action": {
                  "type": "expire"
                }
              }
            ]
          }
      Tags:
        - Key: Name
          Value: !Sub "${ProjectName}-${Environment}-agent-ecr"

  ########################################
  # S3 Buckets for Data Storage
  # Reference: https://docs.aws.amazon.com/AmazonS3/latest/userguide/Welcome.html
  ########################################
  
  DatasetBucket:
    Type: AWS::S3::Bucket
    DependsOn: DatasetProcessorPermission
    Properties:
      BucketName: !Sub "${ProjectName}-${Environment}-dataset-${AWS::AccountId}"
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: aws:kms
              KMSMasterKeyID: !Ref MasterKMSKey
      VersioningConfiguration:
        Status: Enabled
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      LifecycleConfiguration:
        Rules:
          - Id: TransitionToIA
            Status: Enabled
            Transitions:
              - TransitionInDays: 30
                StorageClass: STANDARD_IA
              - TransitionInDays: 90
                StorageClass: INTELLIGENT_TIERING
      NotificationConfiguration:
        LambdaConfigurations:
          - Event: s3:ObjectCreated:*
            Filter:
              S3Key:
                Rules:
                  - Name: prefix
                    Value: documents/
            Function: !GetAtt DatasetProcessorFunction.Arn
      ReplicationConfiguration:
        !If
          - IsProd
          - Role: !GetAtt ReplicationRole.Arn
            Rules:
              - Id: ReplicateToAnotherRegion
                Status: Enabled
                Priority: 1
                DeleteMarkerReplication:
                  Status: Enabled
                Filter:
                  Prefix: ""
                Destination:
                  Bucket: !GetAtt DRDatasetBucket.Arn
                  ReplicationTime:
                    Status: Enabled
                    Time:
                      Minutes: 15
                  Metrics:
                    Status: Enabled
                    EventThreshold:
                      Minutes: 15
                  StorageClass: STANDARD_IA
          - !Ref AWS::NoValue
      Tags:
        - Key: Name
          Value: !Sub "${ProjectName}-${Environment}-dataset"
        - Key: Purpose
          Value: "Knowledge Base Data Source"

  FrontendBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "${ProjectName}-${Environment}-frontend-${AWS::AccountId}"
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: aws:kms
              KMSMasterKeyID: !Ref MasterKMSKey
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
      WebsiteConfiguration:
        IndexDocument: index.html
        ErrorDocument: error.html
      CorsConfiguration:
        CorsRules:
          - AllowedHeaders: ['*']
            AllowedMethods: [GET, HEAD]
            AllowedOrigins: ['*']
            MaxAge: 3000
      Tags:
        - Key: Name
          Value: !Sub "${ProjectName}-${Environment}-frontend"

  AgentCoreBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "${ProjectName}-${Environment}-agentcore-${AWS::AccountId}"
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: aws:kms
              KMSMasterKeyID: !Ref MasterKMSKey
      VersioningConfiguration:
        Status: Enabled
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      LifecycleConfiguration:
        Rules:
          - Id: DeleteOldLogs
            Status: Enabled
            Prefix: logs/
            ExpirationInDays: 90
          - Id: DeleteOldStatus
            Status: Enabled
            Prefix: status/
            ExpirationInDays: 30
      Tags:
        - Key: Name
          Value: !Sub "${ProjectName}-${Environment}-agentcore"
        - Key: Purpose
          Value: "AgentCore artifacts and logs"

  AccessLogsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "${ProjectName}-${Environment}-logs-${AWS::AccountId}"
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      LifecycleConfiguration:
        Rules:
          - Id: DeleteOldLogs
            Status: Enabled
            ExpirationInDays: 90
            Transitions:
              - TransitionInDays: 30
                StorageClass: STANDARD_IA
      OwnershipControls:
        Rules:
          - ObjectOwnership: BucketOwnerPreferred
      Tags:
        - Key: Name
          Value: !Sub "${ProjectName}-${Environment}-access-logs"

  DRDatasetBucket:
    Type: AWS::S3::Bucket
    Condition: IsProd
    Properties:
      BucketName: !Sub "${ProjectName}-${Environment}-dataset-dr-${AWS::AccountId}"
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: aws:kms
      VersioningConfiguration:
        Status: Enabled
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      Tags:
        - Key: Name
          Value: !Sub "${ProjectName}-${Environment}-dataset-dr"
        - Key: Purpose
          Value: "Disaster Recovery Replica"

  ########################################
  # VPC and Networking
  # Reference: https://docs.aws.amazon.com/vpc/latest/userguide/
  ########################################
  
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: !Ref VpcCidr
      EnableDnsHostnames: true
      EnableDnsSupport: true
      Tags:
        - Key: Name
          Value: !Sub "${ProjectName}-${Environment}-vpc"

  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: !Sub "${ProjectName}-${Environment}-igw"

  AttachGateway:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref VPC
      InternetGatewayId: !Ref InternetGateway

  PublicSubnetA:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: !Ref PublicSubnetACidr
      AvailabilityZone: !Select [0, !GetAZs '']
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub "${ProjectName}-${Environment}-public-subnet-a"

  PublicSubnetB:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: !Ref PublicSubnetBCidr
      AvailabilityZone: !Select [1, !GetAZs '']
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub "${ProjectName}-${Environment}-public-subnet-b"

  PrivateSubnetA:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: !Ref PrivateSubnetACidr
      AvailabilityZone: !Select [0, !GetAZs '']
      Tags:
        - Key: Name
          Value: !Sub "${ProjectName}-${Environment}-private-subnet-a"

  PrivateSubnetB:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: !Ref PrivateSubnetBCidr
      AvailabilityZone: !Select [1, !GetAZs '']
      Tags:
        - Key: Name
          Value: !Sub "${ProjectName}-${Environment}-private-subnet-b"

  NATGatewayEIP:
    Type: AWS::EC2::EIP
    DependsOn: AttachGateway
    Properties:
      Domain: vpc
      Tags:
        - Key: Name
          Value: !Sub "${ProjectName}-${Environment}-nat-eip"

  NATGateway:
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt NATGatewayEIP.AllocationId
      SubnetId: !Ref PublicSubnetA
      Tags:
        - Key: Name
          Value: !Sub "${ProjectName}-${Environment}-nat"

  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub "${ProjectName}-${Environment}-public-rt"

  PublicRoute:
    Type: AWS::EC2::Route
    DependsOn: AttachGateway
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  PublicSubnetARouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnetA
      RouteTableId: !Ref PublicRouteTable

  PublicSubnetBRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnetB
      RouteTableId: !Ref PublicRouteTable

  PrivateRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub "${ProjectName}-${Environment}-private-rt"

  PrivateRoute:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref NATGateway

  PrivateSubnetARouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PrivateSubnetA
      RouteTableId: !Ref PrivateRouteTable

  PrivateSubnetBRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PrivateSubnetB
      RouteTableId: !Ref PrivateRouteTable

  VPCEndpointSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub "${ProjectName}-${Environment}-vpc-endpoint-sg"
      GroupDescription: "Security group for VPC endpoints"
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: !Ref VpcCidr
      Tags:
        - Key: Name
          Value: !Sub "${ProjectName}-${Environment}-vpc-endpoint-sg"

  SSMInstanceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub "${ProjectName}-${Environment}-ssm-instance-sg"
      GroupDescription: "Security group for SSM-managed EC2 instances"
      VpcId: !Ref VPC
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0
      Tags:
        - Key: Name
          Value: !Sub "${ProjectName}-${Environment}-ssm-instance-sg"

  VPCEndpointS3:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref VPC
      ServiceName: !Sub "com.amazonaws.${AWS::Region}.s3"
      VpcEndpointType: Gateway
      RouteTableIds:
        - !Ref PrivateRouteTable
        - !Ref PublicRouteTable

  VPCEndpointBedrock:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref VPC
      ServiceName: !Sub "com.amazonaws.${AWS::Region}.bedrock-runtime"
      VpcEndpointType: Interface
      PrivateDnsEnabled: true
      SubnetIds:
        - !Ref PrivateSubnetA
        - !Ref PrivateSubnetB
      SecurityGroupIds:
        - !Ref VPCEndpointSecurityGroup

  ########################################
  # IAM Roles for SSM Automation and AgentCore
  # Reference: https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-setup.html
  ########################################
  
  # Role for SSM Automation Document execution
  SSMAutomationRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${ProjectName}-${Environment}-SSMAutomationRole"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: 
                - ssm.amazonaws.com
                - ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      Policies:
        - PolicyName: SSMAutomationPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              # EC2 permissions to create/manage instances
              - Effect: Allow
                Action:
                  - ec2:RunInstances
                  - ec2:TerminateInstances
                  - ec2:DescribeInstances
                  - ec2:DescribeInstanceStatus
                  - ec2:CreateTags
                Resource: "*"
              # IAM permissions to create/manage roles
              - Effect: Allow
                Action:
                  - iam:CreateRole
                  - iam:DeleteRole
                  - iam:AttachRolePolicy
                  - iam:DetachRolePolicy
                  - iam:PutRolePolicy
                  - iam:DeleteRolePolicy
                  - iam:GetRole
                  - iam:PassRole
                  - iam:CreateInstanceProfile
                  - iam:DeleteInstanceProfile
                  - iam:AddRoleToInstanceProfile
                  - iam:RemoveRoleFromInstanceProfile
                  - iam:GetInstanceProfile
                Resource: 
                  - !Sub "arn:aws:iam::${AWS::AccountId}:role/${ProjectName}-*"
                  - !Sub "arn:aws:iam::${AWS::AccountId}:instance-profile/${ProjectName}-*"
              # S3 permissions for agent code and artifacts
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:ListBucket
                Resource:
                  - !GetAtt AgentCoreBucket.Arn
                  - !Sub "${AgentCoreBucket.Arn}/*"
              # CodeBuild permissions for container builds
              - Effect: Allow
                Action:
                  - codebuild:CreateProject
                  - codebuild:DeleteProject
                  - codebuild:StartBuild
                  - codebuild:BatchGetBuilds
                Resource: !Sub "arn:aws:codebuild:${AWS::Region}:${AWS::AccountId}:project/${ProjectName}-*"
              # ECR permissions for container registry
              - Effect: Allow
                Action:
                  - ecr:GetAuthorizationToken
                  - ecr:BatchCheckLayerAvailability
                  - ecr:GetDownloadUrlForLayer
                  - ecr:BatchGetImage
                  - ecr:PutImage
                  - ecr:InitiateLayerUpload
                  - ecr:UploadLayerPart
                  - ecr:CompleteLayerUpload
                Resource: 
                  - !GetAtt AgentCoreECRRepository.Arn
                  - "*"
              # Bedrock AgentCore permissions
              - Effect: Allow
                Action:
                  - bedrock:*
                  - bedrock-agent:*
                  - bedrock-agentcore:*
                Resource: "*"
              # Secrets Manager for storing AgentCore endpoint
              - Effect: Allow
                Action:
                  - secretsmanager:CreateSecret
                  - secretsmanager:UpdateSecret
                  - secretsmanager:GetSecretValue
                  - secretsmanager:PutSecretValue
                Resource: !Sub "arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${ProjectName}-*"
              # CloudWatch Logs
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/ssm/*"
              # (Removed unsupported X-Ray configuration actions)
      Tags:
        - Key: Name
          Value: !Sub "${ProjectName}-${Environment}-ssm-automation-role"

  # Instance Profile for SSM Automation Role
  SSMAutomationInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      InstanceProfileName: !Sub "${ProjectName}-${Environment}-SSMAutomationProfile"
      Roles:
        - !Ref SSMAutomationRole

  # Execution role for AgentCore Runtime
  # Reference: https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/runtime-permissions.html
  AgentCoreExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${ProjectName}-${Environment}-AgentCoreExecutionRole"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: AgentCoreExecutionPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              # Bedrock permissions for Knowledge Base and models
              - Effect: Allow
                Action:
                  - bedrock:Retrieve
                  - bedrock:RetrieveAndGenerate
                  - bedrock:InvokeModel
                Resource:
                  - !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:knowledge-base/*"
                  - !Sub "arn:aws:bedrock:${BedrockRegion}::foundation-model/${FoundationModelId}"

              # AgentCore Memory permissions
              # Reference: https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/memory.html
              - Effect: Allow
                Action:
                  - bedrock-agentcore:CreateMemory
                  - bedrock-agentcore:GetMemory
                  - bedrock-agentcore:ListMemories
                  - bedrock-agentcore:UpdateMemory
                  - bedrock-agentcore:DeleteMemory
                  - bedrock-agentcore:CreateEvent
                  - bedrock-agentcore:ListEvents
                  - bedrock-agentcore:RetrieveMemories
                Resource: "*"

              # KMS permissions
              - Effect: Allow
                Action:
                  - kms:Decrypt
                  - kms:GenerateDataKey
                Resource: !GetAtt MasterKMSKey.Arn

              # CloudWatch Logs for observability
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/bedrock-agentcore/*"
                  - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*"

              # X-Ray permissions for traces and observability
              - Effect: Allow
                Action:
                  - xray:PutTraceSegments
                  - xray:PutTelemetryRecords
                  - xray:GetSamplingRules
                  - xray:GetSamplingTargets
                Resource: "*"

              # CloudWatch metrics
              - Effect: Allow
                Action:
                  - cloudwatch:PutMetricData
                Resource: "*"
      Tags:
        - Key: Name
          Value: !Sub "${ProjectName}-${Environment}-agentcore-execution-role"

  ########################################
  # SSM Automation Document for AgentCore Deployment
  # Reference: https://docs.aws.amazon.com/systems-manager/latest/userguide/documents.html
  # Reference: https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/runtime-getting-started-toolkit.html
  ########################################

  ########################################
  # API Gateway for Knowledge Base Access
  # Reference: https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html
  ########################################
  ChatAPI:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: !Sub "${ProjectName}-${Environment}-api"
      ProtocolType: HTTP
      Description: !Sub "API for ${ProjectName} with AgentCore Runtime backend"
      CorsConfiguration:
        AllowOrigins:
          - !If
            - HasCustomDomain
            - !Sub "https://${DomainName}"
            - "*"
        AllowMethods: ["GET","POST","OPTIONS"]
        AllowHeaders: ["Authorization","Content-Type"]
        MaxAge: 300
      Tags:
        Name: !Sub "${ProjectName}-${Environment}-api"

  ChatAPIJwtAuthorizer:
    Type: AWS::ApiGatewayV2::Authorizer
    Properties:
      ApiId: !Ref ChatAPI
      AuthorizerType: JWT
      Name: !Sub "${ProjectName}-${Environment}-jwt"
      IdentitySource: ["$request.header.Authorization"]
      JwtConfiguration:
        Audience: [!Ref UserPoolClient]
        Issuer: !Sub "https://cognito-idp.${AWS::Region}.amazonaws.com/${UserPool}"

  # Lambda function to proxy requests to AgentCore Runtime
  # Reference: https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/runtime-invoke.html
  AgentCoreProxyRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: AgentCoreProxy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              # Bedrock Agent invocation
              - Effect: Allow
                Action:
                  - bedrock:InvokeAgent
                Resource: !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/*"

  AgentCoreProxyFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${ProjectName}-${Environment}-agentcore-proxy"
      Runtime: python3.11
      Handler: index.handler
      Role: !GetAtt AgentCoreProxyRole.Arn
      Timeout: 60
      MemorySize: 512
      TracingConfig:
        Mode: PassThrough
      Environment:
        Variables:
          BEDROCK_REGION: !Ref BedrockRegion
          AGENT_ID: !Ref BedrockAgent
          AGENT_ALIAS_ID: !GetAtt BedrockAgentAlias.AgentAliasId
      Code:
        ZipFile: |
          import boto3
          import json
          import os
          import uuid
          
          # Initialize Bedrock Agent Runtime client
          bedrock_agent_runtime = boto3.client('bedrock-agent-runtime', region_name=os.environ.get('BEDROCK_REGION'))
          
          def handler(event, context):
              """
              Proxy to Bedrock Agent - invokes agent with KB and custom actions.
              Based on AWS Labs pattern: https://github.com/awslabs/genai-bedrock-agent-chatbot
              """
              try:
                  print(f"Event: {json.dumps(event)}")
                  
                  # Extract query parameters
                  query_params = event.get('queryStringParameters') or {}
                  query = query_params.get('q', '').strip()
                  session_id = query_params.get('sessionId', str(uuid.uuid4()))
                  
                  if not query:
                      return {
                          "statusCode": 400,
                          "headers": {"Access-Control-Allow-Origin": "*"},
                          "body": json.dumps({"error": "Query parameter 'q' is required"})
                      }
                  
                  # Extract user ID from JWT claims
                  request_context = event.get('requestContext', {})
                  authorizer = request_context.get('authorizer', {})
                  jwt = authorizer.get('jwt', {})
                  claims = jwt.get('claims', {})
                  user_id = claims.get('sub', 'anonymous')
                  
                  # Invoke Bedrock Agent
                  response = bedrock_agent_runtime.invoke_agent(
                      agentId=os.environ['AGENT_ID'],
                      agentAliasId=os.environ['AGENT_ALIAS_ID'],
                      sessionId=session_id,
                      inputText=query
                  )
                  
                  # Process streaming response
                  answer_parts = []
                  citations = []
                  
                  for event_chunk in response.get('completion', []):
                      if 'chunk' in event_chunk:
                          chunk = event_chunk['chunk']
                          if 'bytes' in chunk:
                              answer_parts.append(chunk['bytes'].decode('utf-8'))
                      
                      # Extract citations if available
                      if 'trace' in event_chunk:
                          trace = event_chunk['trace']
                          if 'trace' in trace and 'orchestrationTrace' in trace['trace']:
                              orch_trace = trace['trace']['orchestrationTrace']
                              if 'observation' in orch_trace:
                                  observation = orch_trace['observation']
                                  if 'knowledgeBaseLookupOutput' in observation:
                                      kb_output = observation['knowledgeBaseLookupOutput']
                                      if 'retrievedReferences' in kb_output:
                                          for ref in kb_output['retrievedReferences']:
                                              citations.append({
                                                  'content': ref.get('content', {}).get('text', ''),
                                                  'location': ref.get('location', {}),
                                                  'score': ref.get('metadata', {}).get('score', 0)
                                              })
                  
                  answer = ''.join(answer_parts)
                  
                  return {
                      "statusCode": 200,
                      "headers": {
                          "Access-Control-Allow-Origin": "*",
                          "Content-Type": "application/json",
                          "X-AgentCore-Session": session_id
                      },
                      "body": json.dumps({
                          "answer": answer,
                          "citations": citations,
                          "sessionId": session_id,
                          "userId": user_id
                      })
                  }
              
              except Exception as e:
                  print(f"Error: {str(e)}")
                  import traceback
                  traceback.print_exc()
                  return {
                      "statusCode": 500,
                      "headers": {"Access-Control-Allow-Origin": "*"},
                      "body": json.dumps({"error": str(e)})
                  }

  ChatAPIIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref ChatAPI
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${AgentCoreProxyFunction.Arn}/invocations"
      PayloadFormatVersion: "2.0"

  ChatAPIRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ChatAPI
      RouteKey: "ANY /chat"
      AuthorizationType: JWT
      AuthorizerId: !Ref ChatAPIJwtAuthorizer
      Target: !Sub "integrations/${ChatAPIIntegration}"

  APILogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/http-api/${ProjectName}-${Environment}"
      RetentionInDays: 14
      KmsKeyArn: !GetAtt MasterKMSKey.Arn

  AgentCoreProxyLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/lambda/${ProjectName}-${Environment}-agentcore-proxy"
      RetentionInDays: 14
      KmsKeyArn: !GetAtt MasterKMSKey.Arn

  UploadHTMLLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/lambda/${ProjectName}-${Environment}-upload-html"
      RetentionInDays: 14
      KmsKeyArn: !GetAtt MasterKMSKey.Arn

  ChatAPIStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref ChatAPI
      StageName: !Ref Environment
      AutoDeploy: true
      Description: !Sub "AgentCore-powered stage for ${Environment}"
      AccessLogSettings:
        DestinationArn: !GetAtt APILogGroup.Arn
        Format: >-
          $context.requestTime $context.requestId $context.identity.sourceIp
          $context.httpMethod $context.routeKey $context.status $context.responseLength
      DefaultRouteSettings:
        ThrottlingBurstLimit: 100
        ThrottlingRateLimit: 50

  AgentCoreProxyPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref AgentCoreProxyFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ChatAPI}/*/*/chat"

  ########################################
  # CloudFront Distribution
  # Reference: https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Introduction.html
  ########################################
  CloudFrontOAI:
    Type: AWS::CloudFront::CloudFrontOriginAccessIdentity
    Properties:
      CloudFrontOriginAccessIdentityConfig:
        Comment: !Sub "OAI for ${ProjectName}-${Environment}"

  FrontendBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref FrontendBucket
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Sid: AllowCloudFrontOAIRead
            Effect: Allow
            Principal:
              CanonicalUser: !GetAtt CloudFrontOAI.S3CanonicalUserId
            Action: s3:GetObject
            Resource: !Sub "${FrontendBucket.Arn}/*"

  AccessLogsBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref AccessLogsBucket
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Sid: AllowCloudFrontDelivery
            Effect: Allow
            Principal:
              Service: delivery.logs.amazonaws.com
            Action: s3:PutObject
            Resource: !Sub "${AccessLogsBucket.Arn}/cloudfront/*"
            Condition:
              StringEquals:
                "s3:x-amz-acl": "bucket-owner-full-control"
          - Sid: AllowLogDeliveryAclCheck
            Effect: Allow
            Principal:
              Service: delivery.logs.amazonaws.com
            Action: s3:GetBucketAcl
            Resource: !GetAtt AccessLogsBucket.Arn

  ApiOriginRequestPolicy:
    Type: AWS::CloudFront::OriginRequestPolicy
    Properties:
      OriginRequestPolicyConfig:
        Name: !Sub "${ProjectName}-${Environment}-api-origin-req"
        HeadersConfig:
          # Authorization header not allowed in CloudFront origin policies
          # JWT auth handled by API Gateway Cognito authorizer
          HeaderBehavior: none
        CookiesConfig:
          CookieBehavior: none
        QueryStringsConfig:
          QueryStringBehavior: whitelist
          QueryStrings: [ "q", "sessionId" ]

  ApiCachePolicyNoCache:
    Type: AWS::CloudFront::CachePolicy
    Properties:
      CachePolicyConfig:
        Name: !Sub "${ProjectName}-${Environment}-api-nocache"
        DefaultTTL: 0
        MaxTTL: 0
        MinTTL: 0
        ParametersInCacheKeyAndForwardedToOrigin:
          # When caching is disabled (TTL=0), compression settings must be false
          EnableAcceptEncodingGzip: false
          EnableAcceptEncodingBrotli: false
          HeadersConfig:
            HeaderBehavior: none
          CookiesConfig:
            CookieBehavior: none
          QueryStringsConfig:
            # When caching is disabled, query strings forwarded via OriginRequestPolicy
            QueryStringBehavior: none

  FrontendCachePolicy:
    Type: AWS::CloudFront::CachePolicy
    Properties:
      CachePolicyConfig:
        Name: !Sub "${ProjectName}-${Environment}-frontend-cache"
        DefaultTTL: 86400 # 24 hours
        MaxTTL: 31536000 # 1 year
        MinTTL: 60
        ParametersInCacheKeyAndForwardedToOrigin:
          EnableAcceptEncodingGzip: true
          EnableAcceptEncodingBrotli: true
          HeadersConfig:
            HeaderBehavior: none
          CookiesConfig:
            CookieBehavior: none
          QueryStringsConfig:
            QueryStringBehavior: none

  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        Comment: !Sub "${ProjectName}-${Environment} web distribution"
        DefaultRootObject: index.html
        Origins:
          - Id: FrontendS3Origin
            DomainName: !GetAtt FrontendBucket.RegionalDomainName
            S3OriginConfig:
              OriginAccessIdentity: !Sub "origin-access-identity/cloudfront/${CloudFrontOAI}"
          - Id: ApiOrigin
            DomainName: !Sub "${ChatAPI}.execute-api.${AWS::Region}.amazonaws.com"
            OriginPath: !Sub "/${Environment}"
            CustomOriginConfig: 
              OriginProtocolPolicy: https-only
              HTTPSPort: 443
        DefaultCacheBehavior:
          TargetOriginId: FrontendS3Origin
          ViewerProtocolPolicy: redirect-to-https
          Compress: true
          CachePolicyId: !Ref FrontendCachePolicy
        CacheBehaviors:
          - PathPattern: "/chat*"
            TargetOriginId: ApiOrigin
            ViewerProtocolPolicy: https-only
            AllowedMethods: [GET, HEAD, OPTIONS, POST]
            CachePolicyId: !Ref ApiCachePolicyNoCache
            OriginRequestPolicyId: !Ref ApiOriginRequestPolicy
        CustomErrorResponses:
          - { ErrorCode: 403, ResponseCode: 200, ResponsePagePath: "/index.html" }
          - { ErrorCode: 404, ResponseCode: 200, ResponsePagePath: "/index.html" }
        Logging:
          Bucket: !GetAtt AccessLogsBucket.DomainName
          Prefix: "cloudfront/"
        PriceClass: PriceClass_100
      Tags:
        - Key: Name
          Value: !Sub "${ProjectName}-${Environment}-cdn"

  ########################################
  # Upload Frontend HTML
  ########################################
  UploadHTMLRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - s3:PutObject
                Resource: !Sub "${FrontendBucket.Arn}/*"

  UploadHTMLFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${ProjectName}-${Environment}-upload-html"
      Runtime: python3.11
      Handler: index.handler
      Role: !GetAtt UploadHTMLRole.Arn
      Timeout: 60
      TracingConfig:
        Mode: PassThrough
      Environment:
        Variables:
          BUCKET_NAME: !Ref FrontendBucket
          PROJECT_NAME: !Ref ProjectName
          ENVIRONMENT: !Ref Environment
          API_ENDPOINT: !Sub "https://${ChatAPI}.execute-api.${AWS::Region}.amazonaws.com/${Environment}/chat"
      Code:
        ZipFile: |
          import boto3
          import json
          import urllib.request
          import os
          
          s3 = boto3.client('s3')
          
          def send_response(event, context, status, data=None, reason=None):
              response_body = {
                  'Status': status,
                  'Reason': reason or f"See CloudWatch Log: {context.log_stream_name}",
                  'PhysicalResourceId': context.log_stream_name,
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'Data': data or {}
              }
              
              req = urllib.request.Request(
                  event['ResponseURL'],
                  data=json.dumps(response_body).encode('utf-8'),
                  method='PUT'
              )
              req.add_header('Content-Type', '')
              urllib.request.urlopen(req)
          
          def handler(event, context):
              try:
                  if event['RequestType'] in ['Create', 'Update']:
                      bucket = os.environ['BUCKET_NAME']
                      project = os.environ['PROJECT_NAME']
                      env = os.environ['ENVIRONMENT']
                      api_endpoint = os.environ['API_ENDPOINT']
                      
                      html = '<!DOCTYPE html><html><head><title>AgentCore Chatbot</title></head><body style="font-family:sans-serif;text-align:center;padding:50px;"><h1>AgentCore Chatbot Deployed</h1><p>Check CloudFormation outputs for API endpoint.</p></body></html>'
                      
                      s3.put_object(
                          Bucket=bucket,
                          Key='index.html',
                          Body=html.encode('utf-8'),
                          ContentType='text/html'
                      )
                  
                  send_response(event, context, 'SUCCESS', {'uploaded': True})
              
              except Exception as e:
                  print(f"Error: {str(e)}")
                  send_response(event, context, 'FAILED', reason=str(e))

  UploadHTML:
    Type: Custom::UploadHTML
    Properties:
      ServiceToken: !GetAtt UploadHTMLFunction.Arn

  ########################################
  # Monitoring and Alerts
  # Reference: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/
  ########################################
  AlertsTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !Sub "${ProjectName}-${Environment}-alerts"
      DisplayName: !Sub "${ProjectName} ${Environment} Alerts"
      KmsMasterKeyId: !Ref MasterKMSKey
      Tags:
        - Key: Name
          Value: !Sub "${ProjectName}-${Environment}-alerts"

  AlertsTopicPolicy:
    Type: AWS::SNS::TopicPolicy
    Properties:
      Topics: [!Ref AlertsTopic]
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Sid: AllowBudgetsToPublish
            Effect: Allow
            Principal:
              Service: budgets.amazonaws.com
            Action: sns:Publish
            Resource: !Ref AlertsTopic
          - Sid: AllowCloudWatchAlarms
            Effect: Allow
            Principal:
              Service: cloudwatch.amazonaws.com
            Action: sns:Publish
            Resource: !Ref AlertsTopic

  APILatencyAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub "${ProjectName}-${Environment}-api-latency"
      AlarmDescription: "Alert on high p99 API latency (>3000 ms)"
      Namespace: AWS/ApiGateway
      MetricName: Latency
      Dimensions:
        - { Name: ApiId, Value: !Ref ChatAPI }
        - { Name: Stage, Value: !Ref Environment }
      ExtendedStatistic: "p99.0"
      Period: 300
      EvaluationPeriods: 2
      Threshold: 3000
      ComparisonOperator: GreaterThanThreshold
      TreatMissingData: notBreaching
      AlarmActions: [!Ref AlertsTopic]

  CostBudget:
    Type: AWS::Budgets::Budget
    Condition: EnableCostAlertsCondition
    Properties:
      Budget:
        BudgetName: !Sub "${ProjectName}-${Environment}-budget"
        BudgetType: COST
        TimeUnit: MONTHLY
        BudgetLimit: { Amount: !Ref MonthlyBudgetAmount, Unit: USD }
      NotificationsWithSubscribers:
        - Notification: 
            NotificationType: ACTUAL
            ComparisonOperator: GREATER_THAN
            ThresholdType: PERCENTAGE
            Threshold: 80
          Subscribers: 
            - SubscriptionType: SNS
              Address: !Ref AlertsTopic
        - Notification: 
            NotificationType: ACTUAL
            ComparisonOperator: GREATER_THAN
            ThresholdType: PERCENTAGE
            Threshold: 100
          Subscribers: 
            - SubscriptionType: SNS
              Address: !Ref AlertsTopic


  OSSEncryptionPolicy:
    Type: AWS::OpenSearchServerless::SecurityPolicy
    Properties:
      Name: !Sub "${ProjectName}-${Environment}-enc"
      Type: encryption
      Policy: !Sub |
        {
          "Rules": [
            {
              "ResourceType": "collection",
              "Resource": ["collection/${ProjectName}-${Environment}-vectors"]
            }
          ],
          "AWSOwnedKey": true
        }

  OSSNetworkPolicy:
    Type: AWS::OpenSearchServerless::SecurityPolicy
    Properties:
      Name: !Sub "${ProjectName}-${Environment}-net"
      Type: network
      Policy: !Sub |
        [
          {
            "Rules": [
              {
                "ResourceType": "collection",
                "Resource": ["collection/${ProjectName}-${Environment}-vectors"]
              },
              {
                "ResourceType": "dashboard",
                "Resource": ["collection/${ProjectName}-${Environment}-vectors"]
              }
            ],
            "AllowFromPublic": true
          }
        ]

  OSSVectorCollection:
    Type: AWS::OpenSearchServerless::Collection
    DependsOn:
      - OSSEncryptionPolicy
      - OSSNetworkPolicy
    Properties:
      Name: !Sub "${ProjectName}-${Environment}-vectors"
      Type: VECTORSEARCH
      Description: "Vector collection for knowledge base embeddings"
      Tags:
        - Key: Name
          Value: !Sub "${ProjectName}-${Environment}-vector-collection"

  OSSDataAccessPolicy:
    Type: AWS::OpenSearchServerless::AccessPolicy
    DependsOn: OSSVectorCollection
    Properties:
      Name: !Sub "${ProjectName}-${Environment}-data"
      Type: data
      Policy: !Sub |
        [
          {
            "Rules": [
              {
                "ResourceType": "collection",
                "Resource": ["collection/${ProjectName}-${Environment}-vectors"],
                "Permission": [
                  "aoss:CreateCollectionItems",
                  "aoss:UpdateCollectionItems",
                  "aoss:DescribeCollectionItems"
                ]
              },
              {
                "ResourceType": "index",
                "Resource": ["index/${ProjectName}-${Environment}-vectors/${ProjectName}-${Environment}-index"],
                "Permission": [
                  "aoss:CreateIndex",
                  "aoss:UpdateIndex",
                  "aoss:DescribeIndex",
                  "aoss:ReadDocument",
                  "aoss:WriteDocument"
                ]
              }
            ],
            "Principal": [
              "${BedrockKBRole.Arn}"
            ]
          }
        ]

  ########################################
  # Bedrock Knowledge Base
  # Reference: https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base.html
  ########################################

  BedrockKBRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${ProjectName}-${Environment}-bedrock-kb-role"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement: 
          - Effect: Allow
            Principal: 
              Service: bedrock.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                "aws:SourceAccount": !Ref AWS::AccountId
              ArnLike:
                "aws:SourceArn": !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:knowledge-base/*"
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: 
                  - s3:GetObject
                  - s3:ListBucket
                Resource:
                  - !Sub "arn:aws:s3:::${ProjectName}-${Environment}-dataset-${AWS::AccountId}"
                  - !Sub "arn:aws:s3:::${ProjectName}-${Environment}-dataset-${AWS::AccountId}/*"
        - PolicyName: OpenSearchAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - aoss:APIAccessAll
                Resource: !Sub "arn:aws:aoss:${AWS::Region}:${AWS::AccountId}:collection/*"
        - PolicyName: BedrockModelAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                Resource: !Sub "arn:aws:bedrock:${BedrockRegion}::foundation-model/${EmbeddingModelId}"

  BedrockKnowledgeBase:
    Type: AWS::Bedrock::KnowledgeBase
    DependsOn: 
      - OSSVectorCollection
      - OSSDataAccessPolicy
    Properties:
      Name: !Sub "${ProjectName}-${Environment}-knowledge-base"
      Description: "Knowledge base for contextual chatbot with hybrid search"
      RoleArn: !GetAtt BedrockKBRole.Arn
      KnowledgeBaseConfiguration:
        Type: VECTOR
        VectorKnowledgeBaseConfiguration:
          EmbeddingModelArn: !Sub "arn:aws:bedrock:${BedrockRegion}::foundation-model/${EmbeddingModelId}"
      StorageConfiguration:
        Type: OPENSEARCH_SERVERLESS
        OpensearchServerlessConfiguration:
          CollectionArn: !GetAtt OSSVectorCollection.Arn
          VectorIndexName: !Sub "${ProjectName}-${Environment}-index"
          FieldMapping: 
            VectorField: vector
            TextField: text
            MetadataField: metadata
      Tags:
        Name: !Sub "${ProjectName}-${Environment}-kb"

  BedrockDataSource:
    Type: AWS::Bedrock::DataSource
    Properties:
      Name: !Sub "${ProjectName}-${Environment}-s3-datasource"
      Description: "S3 data source for knowledge base"
      KnowledgeBaseId: !Ref BedrockKnowledgeBase
      DataSourceConfiguration:
        Type: S3
        S3Configuration:
          BucketArn: !GetAtt DatasetBucket.Arn
          InclusionPrefixes:
            - "documents/"
      VectorIngestionConfiguration:
        ChunkingConfiguration:
          ChunkingStrategy: FIXED_SIZE
          FixedSizeChunkingConfiguration:
            MaxTokens: 300
            OverlapPercentage: 20

  ########################################
  # Bedrock Agent
  # Reference: https://docs.aws.amazon.com/bedrock/latest/userguide/agents.html
  ########################################

  BedrockAgentRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${ProjectName}-${Environment}-bedrock-agent-role"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                "aws:SourceAccount": !Ref AWS::AccountId
              ArnLike:
                "aws:SourceArn": !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/*"
      Policies:
        - PolicyName: BedrockAgentPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              # Knowledge Base access
              - Effect: Allow
                Action:
                  - bedrock:Retrieve
                  - bedrock:RetrieveAndGenerate
                Resource: !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:knowledge-base/*"
              # Model invocation
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                Resource: !Sub "arn:aws:bedrock:${BedrockRegion}::foundation-model/${FoundationModelId}"
              # Action group Lambda invocation
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource: !GetAtt AgentActionLambda.Arn

  AgentActionLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${ProjectName}-${Environment}-agent-action-role"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: AgentActionPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              # Knowledge Base query access (for custom actions)
              - Effect: Allow
                Action:
                  - bedrock:Retrieve
                Resource: !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:knowledge-base/*"
              # S3 access for reading documents
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                Resource:
                  - !Sub "arn:aws:s3:::${ProjectName}-${Environment}-dataset-${AWS::AccountId}"
                  - !Sub "arn:aws:s3:::${ProjectName}-${Environment}-dataset-${AWS::AccountId}/*"

  AgentActionLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${ProjectName}-${Environment}-agent-action"
      Runtime: python3.11
      Handler: index.handler
      Role: !GetAtt AgentActionLambdaRole.Arn
      Timeout: 60
      Environment:
        Variables:
          KNOWLEDGE_BASE_ID: !Ref BedrockKnowledgeBase
          BEDROCK_REGION: !Ref BedrockRegion
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          
          bedrock_agent_runtime = boto3.client('bedrock-agent-runtime', region_name=os.environ['BEDROCK_REGION'])
          
          def handler(event, context):
              """
              Agent action handler - processes custom actions for the Bedrock Agent.
              This is similar to AWS Labs example action lambda.
              """
              print(f"Event: {json.dumps(event)}")
              
              # Extract action group, API path, and parameters
              agent = event.get('agent', {})
              api_path = event.get('apiPath', '')
              parameters = event.get('parameters', [])
              
              # Parse parameters into a dict
              params = {p['name']: p['value'] for p in parameters}
              
              response_body = {}
              
              try:
                  # Example action: Query knowledge base with specific parameters
                  if api_path == '/queryKnowledge':
                      query = params.get('query', '')
                      
                      kb_response = bedrock_agent_runtime.retrieve(
                          knowledgeBaseId=os.environ['KNOWLEDGE_BASE_ID'],
                          retrievalQuery={'text': query},
                          retrievalConfiguration={
                              'vectorSearchConfiguration': {
                                  'numberOfResults': 5
                              }
                          }
                      )
                      
                      # Extract retrieved results
                      results = []
                      for result in kb_response.get('retrievalResults', []):
                          results.append({
                              'content': result.get('content', {}).get('text', ''),
                              'score': result.get('score', 0)
                          })
                      
                      response_body = {
                          'query': query,
                          'results': results,
                          'count': len(results)
                      }
                  
                  # Example action: Get document count
                  elif api_path == '/getDocumentCount':
                      # This is a placeholder - in real implementation, 
                      # you would query your data source
                      response_body = {
                          'documentCount': 'Retrieved from S3',
                          'status': 'success'
                      }
                  
                  else:
                      response_body = {
                          'error': f'Unknown API path: {api_path}'
                      }
                  
              except Exception as e:
                  print(f"Error: {str(e)}")
                  response_body = {
                      'error': str(e)
                  }
              
              # Return response in Bedrock Agent format
              return {
                  'messageVersion': '1.0',
                  'response': {
                      'actionGroup': event.get('actionGroup', ''),
                      'apiPath': api_path,
                      'httpMethod': event.get('httpMethod', ''),
                      'httpStatusCode': 200,
                      'responseBody': {
                          'application/json': {
                              'body': json.dumps(response_body)
                          }
                      }
                  }
              }

  AgentActionLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref AgentActionLambda
      Action: lambda:InvokeFunction
      Principal: bedrock.amazonaws.com
      SourceAccount: !Ref AWS::AccountId
      SourceArn: !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/*"

  BedrockAgent:
    Type: AWS::Bedrock::Agent
    DependsOn:
      - BedrockKnowledgeBase
      - AgentActionLambda
    Properties:
      AgentName: !Sub "${ProjectName}-${Environment}-agent"
      Description: "AI agent with knowledge base and custom actions for contextual chatbot"
      AgentResourceRoleArn: !GetAtt BedrockAgentRole.Arn
      FoundationModel: !Ref FoundationModelId
      Instruction: |
        You are a helpful AI assistant with access to a knowledge base and custom actions.
        
        Your capabilities:
        1. Answer questions using the knowledge base - search through documents to find relevant information
        2. Query specific knowledge using custom actions when needed
        3. Provide accurate, helpful responses with citations
        
        When answering:
        - Always search the knowledge base first for relevant information
        - Cite your sources when providing information from documents
        - Be concise but thorough
        - If you don't know something, say so honestly
        - Use custom actions when you need to perform specific queries
      KnowledgeBases:
        - KnowledgeBaseId: !Ref BedrockKnowledgeBase
          Description: "Main knowledge base with document corpus"
          KnowledgeBaseState: ENABLED
      ActionGroups:
        - ActionGroupName: CustomActions
          Description: "Custom actions for specialized queries"
          ActionGroupExecutor:
            Lambda: !GetAtt AgentActionLambda.Arn
          ActionGroupState: ENABLED
          ApiSchema:
            Payload: |
              {
                "openapi": "3.0.0",
                "info": {
                  "title": "Agent Custom Actions API",
                  "version": "1.0.0",
                  "description": "Custom actions for the Bedrock Agent"
                },
                "paths": {
                  "/queryKnowledge": {
                    "post": {
                      "summary": "Query knowledge base with specific parameters",
                      "description": "Performs a targeted knowledge base query",
                      "operationId": "queryKnowledge",
                      "requestBody": {
                        "required": true,
                        "content": {
                          "application/json": {
                            "schema": {
                              "type": "object",
                              "properties": {
                                "query": {
                                  "type": "string",
                                  "description": "The query text to search for"
                                }
                              },
                              "required": ["query"]
                            }
                          }
                        }
                      },
                      "responses": {
                        "200": {
                          "description": "Successful query response",
                          "content": {
                            "application/json": {
                              "schema": {
                                "type": "object",
                                "properties": {
                                  "query": {"type": "string"},
                                  "results": {"type": "array"},
                                  "count": {"type": "integer"}
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  "/getDocumentCount": {
                    "get": {
                      "summary": "Get document count",
                      "description": "Returns the number of documents in the knowledge base",
                      "operationId": "getDocumentCount",
                      "responses": {
                        "200": {
                          "description": "Document count response",
                          "content": {
                            "application/json": {
                              "schema": {
                                "type": "object",
                                "properties": {
                                  "documentCount": {"type": "string"},
                                  "status": {"type": "string"}
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }

  BedrockAgentAlias:
    Type: AWS::Bedrock::AgentAlias
    Properties:
      AgentId: !Ref BedrockAgent
      AgentAliasName: !Sub "${Environment}-alias"
      Description: !Sub "Agent alias for ${Environment} environment"

  ########################################
  # Supporting IAM Roles
  ########################################
  
  ReplicationRole:
    Type: AWS::IAM::Role
    Condition: IsProd
    Properties:
      RoleName: !Sub "${ProjectName}-${Environment}-replication-role"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: s3.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: ReplicationPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetReplicationConfiguration
                  - s3:ListBucket
                Resource: !Sub "arn:aws:s3:::${ProjectName}-${Environment}-dataset-${AWS::AccountId}"
              - Effect: Allow
                Action:
                  - s3:GetObjectVersionForReplication
                  - s3:GetObjectVersionAcl
                  - s3:GetObjectVersionTagging
                Resource: !Sub "arn:aws:s3:::${ProjectName}-${Environment}-dataset-${AWS::AccountId}/*"
              - Effect: Allow
                Action:
                  - s3:ReplicateObject
                  - s3:ReplicateDelete
                  - s3:ReplicateTags
                Resource: !Sub "arn:aws:s3:::${ProjectName}-${Environment}-dataset-dr-${AWS::AccountId}/*"

  DatasetProcessorFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${ProjectName}-${Environment}-dataset-processor"
      Runtime: python3.11
      Handler: index.handler
      Role: !GetAtt DatasetProcessorRole.Arn
      Timeout: 300
      Environment:
        Variables:
          KNOWLEDGE_BASE_ID: !Ref BedrockKnowledgeBase
      Code:
        ZipFile: |
          import boto3
          import json
          import os
          
          bedrock = boto3.client('bedrock')
          
          def _find_data_source_id(kb_id: str) -> str:
              """Find the first data source on this KB (runtime lookup)"""
              paginator = bedrock.get_paginator('list_data_sources')
              for page in paginator.paginate(knowledgeBaseId=kb_id):
                  for ds in page.get('dataSourceSummaries', []):
                      return ds['dataSourceId']
              raise RuntimeError(f"No data sources found for KB {kb_id}")
          
          def handler(event, context):
              print(f"Received event: {json.dumps(event)}")
              
              kb_id = os.environ['KNOWLEDGE_BASE_ID']
              
              try:
                  # Runtime lookup to break circular dependency in CFN
                  ds_id = _find_data_source_id(kb_id)
                  print(f"Found data source: {ds_id}")
                  
                  # Trigger knowledge base ingestion
                  response = bedrock.start_ingestion_job(
                      knowledgeBaseId=kb_id,
                      dataSourceId=ds_id
                  )
                  print(f"Started ingestion job: {response['ingestionJob']['ingestionJobId']}")
                  return {'statusCode': 200, 'body': 'Ingestion started'}
              except Exception as e:
                  print(f"Error: {str(e)}")
                  raise

  DatasetProcessorRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${ProjectName}-${Environment}-dataset-processor-role"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: BedrockAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:StartIngestionJob
                  - bedrock:GetIngestionJob
                  - bedrock:ListDataSources
                  - bedrock:GetDataSource
                Resource:
                  - !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:knowledge-base/*"
                  - !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:knowledge-base/*/data-source/*"

  DatasetProcessorPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref DatasetProcessorFunction
      Action: lambda:InvokeFunction
      Principal: s3.amazonaws.com
      # Use literal ARN so this permission doesn't depend on the bucket,
      # allowing the bucket to DependsOn this permission without creating a cycle
      SourceArn: !Sub "arn:aws:s3:::${ProjectName}-${Environment}-dataset-${AWS::AccountId}"
      SourceAccount: !Ref AWS::AccountId

  ########################################
  # Cognito User Pool
  # Reference: https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html
  ########################################
  UserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UserPoolName: !Sub "${ProjectName}-${Environment}-users"
      UsernameAttributes: [ email ]
      AutoVerifiedAttributes: [ email ]
      Policies: 
        PasswordPolicy: 
          MinimumLength: 8
          RequireUppercase: true
          RequireLowercase: true
          RequireNumbers: true
          RequireSymbols: true
      MfaConfiguration: "OFF"
      Schema:
        - { Name: email, AttributeDataType: String, Required: true, Mutable: false }
        - { Name: name, AttributeDataType: String, Required: false, Mutable: true }
      AccountRecoverySetting: 
        RecoveryMechanisms: 
          - { Name: verified_email, Priority: 1 }
      UserPoolTags:
        Name: !Sub "${ProjectName}-${Environment}-user-pool"

  UserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      ClientName: !Sub "${ProjectName}-${Environment}-client"
      UserPoolId: !Ref UserPool
      GenerateSecret: false
      AllowedOAuthFlowsUserPoolClient: true
      AllowedOAuthFlows: [ code, implicit ]
      AllowedOAuthScopes: [ email, openid, profile ]
      CallbackURLs: 
        - !If
          - HasCustomDomain
          - !Sub "https://${DomainName}/callback"
          - "http://localhost:3000/callback"
      LogoutURLs:
        - !If
          - HasCustomDomain
          - !Sub "https://${DomainName}/logout"
          - "http://localhost:3000/logout"
      SupportedIdentityProviders: [ COGNITO ]


Outputs:
  FrontendURL:
    Description: CloudFront URL for web application
    Value: !Sub "https://${CloudFrontDistribution.DomainName}"
    Export:
      Name: !Sub "${ProjectName}-${Environment}-FrontendURL"


  ChatApiInvokeURL:
    Description: "HTTP API invoke URL"
    Value: !Sub "https://${ChatAPI}.execute-api.${AWS::Region}.amazonaws.com/${Environment}/chat"
    Export:
      Name: !Sub "${ProjectName}-${Environment}-ApiURL"

  DatasetBucketName:
    Description: "S3 bucket for document ingestion (upload under documents/)"
    Value: !Ref DatasetBucket
    Export:
      Name: !Sub "${ProjectName}-${Environment}-DatasetBucket"

  KnowledgeBaseId:
    Description: Bedrock Knowledge Base ID
    Value: !Ref BedrockKnowledgeBase
    Export:
      Name: !Sub "${ProjectName}-${Environment}-KnowledgeBaseId"

  DataSourceId:
    Description: Bedrock Data Source ID
    Value: !Ref BedrockDataSource
    Export:
      Name: !Sub "${ProjectName}-${Environment}-DataSourceId"

  OpenSearchCollectionEndpoint:
    Description: OpenSearch Serverless collection endpoint
    Value: !GetAtt OSSVectorCollection.CollectionEndpoint
    Export:
      Name: !Sub "${ProjectName}-${Environment}-VectorEndpoint"

  UserPoolId:
    Description: Cognito User Pool ID
    Value: !Ref UserPool
    Export:
      Name: !Sub "${ProjectName}-${Environment}-UserPoolId"

  UserPoolClientId:
    Description: Cognito User Pool Client ID
    Value: !Ref UserPoolClient
    Export:
      Name: !Sub "${ProjectName}-${Environment}-UserPoolClientId"

  AgentCoreECRRepository:
    Description: ECR Repository for agent container images
    Value: !GetAtt AgentCoreECRRepository.RepositoryUri
    Export:
      Name: !Sub "${ProjectName}-${Environment}-AgentECR"

  AgentCoreSecretName:
    Description: Secrets Manager secret containing AgentCore endpoint ARN
    Value: !Sub "${ProjectName}-${Environment}-agentcore-endpoint"
    Export:
      Name: !Sub "${ProjectName}-${Environment}-AgentCoreSecret"

  BedrockAgentId:
    Description: Bedrock Agent ID (with KB and custom actions)
    Value: !Ref BedrockAgent
    Export:
      Name: !Sub "${ProjectName}-${Environment}-AgentId"

  BedrockAgentAliasId:
    Description: Bedrock Agent Alias ID
    Value: !GetAtt BedrockAgentAlias.AgentAliasId
    Export:
      Name: !Sub "${ProjectName}-${Environment}-AgentAliasId"

  AgentActionLambdaArn:
    Description: Agent Action Lambda ARN
    Value: !GetAtt AgentActionLambda.Arn
    Export:
      Name: !Sub "${ProjectName}-${Environment}-AgentActionLambda"

